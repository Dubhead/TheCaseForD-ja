標準ライブラリについて一言

先に述べたように、Dには本格的なライブラリがPhobosとTangoの2つあり、これが政治的に微妙な問題となっています。
筆者が本格的に取り組んだことがあるのは前者だけですので、ここでは前者についてのみ述べることにします。
私の考えでは、STLの出現によって、コンテナ＋アルゴリズムのライブラリの世界はすっかり変わってしまいました。
その変化があまりに劇的だったため、STLと同種のライブラリで、後発なのにSTLを研究しないまま開発されたものは、もはやマヌケに見えかねません。
(そういうわけで、どんな言語のプログラマであっても、STLを理解しておくことをお勧めします。)
これは、STLが完璧なライブラリだからではありません。実際、違います。
STLはC++の長所にも短所にも密接に結び付いており、そのため例えば、実行効率は良いのですが高階プログラミングのサポートは貧弱になっています。
STLはC++と共存していく関係にあるため、C++プログラマでない人がSTLを抽象的に理解することは困難です。これは、STLの基本的な仕組みからその本質を理解することが難しいためです。
さらにその上、STL自体にも欠点があり、例えば、各種コンテナとそれをイテレイトする方法を概念的な枠組みへ上手くまとめる、という事ができていません。

STLの主な功績は、基本的なコンテナとアルゴリズムのライブラリを書くとはどういうことかという根本的な疑問から始め、その回答を理解した上でそういったライブラリを書く過程を再定義した、という点でした。
STLが投げかけた質問とは、「アルゴリズムがデータを扱う際に、そのデータのトポロジーは最低限どこまで分かっていればよいか?」というものでした。
(訳注: ここでいうトポロジーとは、データの具体的な格納方法や並び方のことか。)
意外なことに、このテーマについて十分厳密に考慮したといえるライブラリ実装者はほとんどいません。アルゴリズム専門家の中にさえ、考慮していない者がいます。
配列でも連結リストでも添字でアクセスしてよいのだ、なぜならアクセスする際のトポロジー的な面などは実装上の問題に過ぎないのだから、といったようにインタフェイスを統合していく観点がありますが、STLの立場はこれとは全く対照的です。
STLはそのようなアプローチのデメリットを明らかにしました。例えば、
統合インタフェイスを使うことにより最低限の線形探索さえ実装すれば済む、といった態度は不誠実であるからです (ｎ二乗オーダーのアルゴリズムが終了するのを待っていられるなら別ですが)。
これらの事実は、アルゴリズムについて少しでも真面目に考えたことのある者の間ではよく知られていますが、しかしどういうわけか、アルゴリズムを理解することと、それをプログラミング言語で最も一般的に実装したものとの間には断絶がありました。
筆者はアルゴリズムには精通していましたが、今となっては、線形探索の純粋で本質的で観念的な部分とは何であるのか、15年前にSTLの線形探索を見るまでは考えたことがなかったと言えます。

回りくどい言い方になりましたが、PhobosはSTLを大いに意識しているのです (ぜひオンライン文書の <b>std.algorithm</b> と <b>std.range</b> を読んでください)。
私に言わせれば、Phobosが提供するアルゴリズムはSTLよりずっと良いもので、その理由は次の2つです。
一つは、先行した巨人たちの肩に乗れたという点で明らかに有利だったこと (小人たちのつま先のことはさておき) 。
もう一つは、優れた言語の力を最大限に使い切っていることです。

<b>今は、イテレイタではなく範囲 (range)  が熱い話題となっています</b>。
おそらく、PhobosがSTLから最もかけ離れている点は、イテレイタが無い点でしょう。
イテレイタによる抽象化は、範囲による抽象化で置き換えられました。こちらの方が、効率は同じくらい良いのに、カプセル化や検証可能性や抽象化の力ははるかに上なのです。
(考えてみれば、イテレイタの基本的操作の中には、自然に検証できるものはありません。これは実に奇妙なことです。)
範囲を使ったコードは同じくらい速く、より安全で、イテレイタを使うコードより簡潔になります − 1行に収まりきらないforループはもう要りません。
実際、範囲で考えコーディングすると非常に簡潔になるので、これまでなら考えつくことは出来たもののイテレイタでやり通そうとすると面倒くさすぎて出来なかったようなイディオムが、新たに見つかってきています。
例えば、2つのシークェンスを順にたどる <b>chain</b> 関数を思い付いたとしましょう。
これはかなり便利そうです。
しかしイテレイタを使う <b>chain</b> は、イテレイタを4つ受け取って2つ返すものになります。これは不恰好すぎて実用になりません。
一方、範囲を使う <b>chain</b> は、範囲を2つ受け取って1つ返します。
さらに、可変個の引数を使えば、 <b>chain</b> に範囲をいくつでも与えることができます − いつの間にか、非常に便利な関数が使えるようになってしまいました。
chainは実際には、標準モジュールの std.range で実装されています。
As an example, here's how you can iterate through three arrays:
例として、3つの配列を順にたどる方法はこうなります:

int[] a, b, c;
...
foreach (e; chain(a, b, c))
{
    ... eを使う処理 ...
}

ここで、配列自体は結合されていない点に注意してください!
chainは、配列はそのまま触らず、単に順番にたどっていくだけなのです。
こう言うと、chainを使えば元の配列の要素を変更していけると思うかもしれませんが、実際そういうことが出来ます。
例えば、以下の例はどうなるか分かりますか?

sort(chain(a, b, c));

ご想像の通りです − 3つの配列の内容全体がまとめてソートされ、その後、配列のサイズは変えずに、最小の要素はaに入り... といった具合に各要素が効率よく並び変えられます。
これはまだ、範囲や、範囲コンビネータがアルゴリズムと連携することによって生み出される可能性のほんの一例に過ぎません。

<b>遅延評価で無限を扱うこと、そしてその先</b>。
STLのアルゴリズムは、他の多くのものと同様に、先行評価です。つまり、リターンしてきた時には仕事はもう全部終わっているのです。
一方Phobosは、そうする意味のある所では、遅延評価を行います。
これにより、Phobosでは、結合する能力が向上し、無限の範囲を扱えるようになっています。
例えば、高階関数 <b>map</b> の原型を考えてみましょう (これは関数型プログラミングの世界でいうmapの方であり、STLにある同名のデータ構造とは別のものです)。
このmapは、与えられた関数を、範囲の各要素に適用します。
もし <b>map</b> をどうしても先行評価にしたいなら、次の2つの問題が出てきます:

<li>一つは、結果を格納するための領域 (リストや配列など) を新たに確保する必要があること。
<li>もう一つは、呼び出し側へ制御を戻す前に、範囲の中身をすべて読み出さなければならないこと。

最初の問題は効率の問題です。メモリ割り当てを避けるべき場合がたくさんあります (例えば、呼び出し側は単にmapの結果を順番に見たいだけだという場合)。
2つ目の問題は根本的です。先行評価な <b>map</b> は、無限の範囲を扱おうとすると、無限ループに入ってしまいます。

これが、Phobosではmapが遅延評価な範囲を返し、そこから要素を取り出すたびに処理を少しずつ進めるよう定義した理由です。
これとは逆に、reduce関数 (ある意味、mapとは逆のもの) は先行評価です。
関数の中には、遅延評価バージョンと先行評価バージョンの両方があるようなものもあります。
例えば、 <b>retro(r)</b> は与えられた範囲 <b>r</b> を逆順にたどる範囲を返しますが、 <b>reverse(r)</b> は <b>r</b> 自体を変更して逆順に並べ変えます。

結論

この概説記事においてさえ、話しておきたい事がもっとありました。ユニットテスト、UTF文字列、コンパイル時の関数評価 (Dプログラムのコンパイル中に走る、一種のDインタプリタ)、動的クロージャ、その他たくさんの事です。
この記事で、読者の方々の好奇心をそそることが出来ていれば幸いです。
もしあなたが、使っていても激痛を感じることのないシステムレベルの言語、退屈しないアプリケイション言語、悪い態度のない理にかなった言語、あるいは −これが最も重要なのですが− その全ての要素を兼ね備えた言語を探しているのならば、Dがその答かもしれません。

ご質問があれば、筆者にメイルを出すか、またはもっと良い方法として、Usenetサーバ news.digitalmars.com に接続して digitalmars.d ニュースグループにポストしてください。ここが、活気のあるD言語コミュニティの中心地となっています。

謝辞

このような記事が必要だと指摘し、タイトルを提案してくれたScott Meyersに感謝の意を表します。
Bill Baxter、Jason House、John "Eljay" Love-Jensen、Denis Koroskin、leonardo maffi (原文まま), Petru M?arginean、Bartosz Milewski、Derek Parnell、Brad Roberts、Joel Salomon、Benjamin Shropshire、David Simcha、Florin Trofin、Cristian Vlasceanu、そしてWalter Brightの方々からは、素晴らしいリヴュー、フィードバック、および提案をいただきました。


# eof
